"use strict";var __importDefault=this&&this.__importDefault||function(a){return a&&a.__esModule?a:{default:a}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.autoPreprocess=void 0;const strip_indent_1=__importDefault(require("strip-indent")),package_json_1=require("svelte/package.json"),hasPostcssInstalled_1=require("./modules/hasPostcssInstalled"),concat_1=require("./modules/concat"),parseFile_1=require("./modules/parseFile"),language_1=require("./modules/language"),transformers_1=require("./modules/transformers"),errors_1=require("./modules/errors"),SVELTE_MAJOR_VERSION=+package_json_1.version[0],ALIAS_OPTION_OVERRIDES={sass:{indentedSyntax:!0}};function autoPreprocess({onBefore:a,aliases:b,markupTagName:d="template",preserve:e=[],...c}={}){d=d.toLocaleLowerCase();const f={},g=c.transformers||c,h=new RegExp(`<${d}([\\s\\S]*?)(?:>([\\s\\S]*)<\\/${d}>|/>)`);(null===b||void 0===b?void 0:b.length)&&language_1.addLanguageAlias(b);const i=(a,b)=>{if("function"==typeof g[b])return g[b];if("function"==typeof g[a])return g[a];if(null!=f[b])return f[b];const c={};return"object"==typeof g[a]&&Object.assign(c,g[a]),a!==b&&(Object.assign(c,ALIAS_OPTION_OVERRIDES[b]||null),"object"==typeof g[b]&&Object.assign(c,g[b])),f[b]=c},j=a=>async b=>{const{content:c,filename:d,lang:f,alias:h,dependencies:j,attributes:k}=await parseFile_1.parseFile(b,a);if(!(e.includes(f)||e.includes(h))){if(f===a)return{code:c,dependencies:j};(!1===g[f]||!1===g[h])&&errors_1.throwUnsupportedError(h,d);const b=await transformers_1.runTransformer(f,i(f,h),{content:strip_indent_1.default(c),filename:d,attributes:k});return{...b,dependencies:concat_1.concat(j,b.dependencies)}}},k=j("javascript"),l=j("css"),m=j("html");return{async markup({content:b,filename:c}){if("function"==typeof a&&(3<=SVELTE_MAJOR_VERSION&&console.warn("[svelte-preprocess] For svelte >= v3, instead of onBefore(), prefer to prepend a preprocess object to your array of preprocessors"),b=await a({content:b,filename:c})),g.replace){const a=await transformers_1.runTransformer("replace",g.replace,{content:b,filename:c});b=a.code}const d=b.match(h);if(!d)return{code:b};const[e,f,i]=d,j=f.split(/\s+/).filter(Boolean).reduce((a,b)=>{const[c,d]=b.split("=");return a[c]=!d||d.replace(/['"]/g,""),a},{});let{code:k,map:l,dependencies:n}=await m({content:i,attributes:j,filename:c});return k=b.slice(0,d.index)+k+b.slice(d.index+e.length),{code:k,map:l,dependencies:n}},async script({content:a,attributes:b,filename:c}){const d=await k({content:a,attributes:b,filename:c});if(null==d)return;let{code:e,map:f,dependencies:h,diagnostics:i}=d;if(g.babel){const a=await transformers_1.runTransformer("babel",g.babel,{content:e,map:f,filename:c,attributes:b});e=a.code,f=a.map,h=concat_1.concat(h,a.dependencies),i=concat_1.concat(i,a.diagnostics)}return{code:e,map:f,dependencies:h,diagnostics:i}},async style({content:a,attributes:b,filename:c}){const d=await l({content:a,attributes:b,filename:c});if(null==d)return;let{code:e,map:f,dependencies:h}=d;if(g.postcss){const a=await transformers_1.runTransformer("postcss",g.postcss,{content:e,map:f,filename:c,attributes:b});e=a.code,f=a.map,h=concat_1.concat(h,a.dependencies)}if(await hasPostcssInstalled_1.hasPostCssInstalled()){const a=await transformers_1.runTransformer("globalStyle",null===g||void 0===g?void 0:g.globalStyle,{content:e,map:f,filename:c,attributes:b});e=a.code,f=a.map}return{code:e,map:f,dependencies:h}}}}exports.autoPreprocess=autoPreprocess;