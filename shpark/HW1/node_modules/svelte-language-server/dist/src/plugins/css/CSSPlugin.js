"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CSSPlugin = void 0;
const vscode_emmet_helper_1 = require("vscode-emmet-helper");
const vscode_languageserver_1 = require("vscode-languageserver");
const documents_1 = require("../../lib/documents");
const CSSDocument_1 = require("./CSSDocument");
const service_1 = require("./service");
class CSSPlugin {
    constructor(docManager, configManager) {
        this.cssDocuments = new WeakMap();
        this.triggerCharacters = ['.', ':', '-', '/'];
        this.configManager = configManager;
        docManager.on('documentChange', (document) => this.cssDocuments.set(document, new CSSDocument_1.CSSDocument(document)));
        docManager.on('documentClose', (document) => this.cssDocuments.delete(document));
    }
    getDiagnostics(document) {
        if (!this.featureEnabled('diagnostics')) {
            return [];
        }
        const cssDocument = this.getCSSDoc(document);
        if (isSASS(cssDocument)) {
            return [];
        }
        const kind = extractLanguage(cssDocument);
        if (shouldExcludeValidation(kind)) {
            return [];
        }
        return service_1.getLanguageService(kind)
            .doValidation(cssDocument, cssDocument.stylesheet)
            .map((diagnostic) => ({ ...diagnostic, source: service_1.getLanguage(kind) }))
            .map((diagnostic) => documents_1.mapDiagnosticToOriginal(cssDocument, diagnostic));
    }
    doHover(document, position) {
        if (!this.featureEnabled('hover')) {
            return null;
        }
        const cssDocument = this.getCSSDoc(document);
        if (!cssDocument.isInGenerated(position) || isSASS(cssDocument)) {
            return null;
        }
        const hoverInfo = service_1.getLanguageService(extractLanguage(cssDocument)).doHover(cssDocument, cssDocument.getGeneratedPosition(position), cssDocument.stylesheet);
        return hoverInfo ? documents_1.mapHoverToParent(cssDocument, hoverInfo) : hoverInfo;
    }
    getCompletions(document, position, completionContext) {
        const triggerCharacter = completionContext === null || completionContext === void 0 ? void 0 : completionContext.triggerCharacter;
        const triggerKind = completionContext === null || completionContext === void 0 ? void 0 : completionContext.triggerKind;
        const isCustomTriggerCharater = triggerKind === vscode_languageserver_1.CompletionTriggerKind.TriggerCharacter;
        if (isCustomTriggerCharater &&
            triggerCharacter &&
            !this.triggerCharacters.includes(triggerCharacter)) {
            return null;
        }
        if (!this.featureEnabled('completions')) {
            return null;
        }
        const cssDocument = this.getCSSDoc(document);
        if (!cssDocument.isInGenerated(position) || isSASS(cssDocument)) {
            return null;
        }
        const type = extractLanguage(cssDocument);
        const lang = service_1.getLanguageService(type);
        const emmetResults = {
            isIncomplete: true,
            items: [],
        };
        lang.setCompletionParticipants([
            vscode_emmet_helper_1.getEmmetCompletionParticipants(cssDocument, cssDocument.getGeneratedPosition(position), service_1.getLanguage(type), {}, emmetResults),
        ]);
        const results = lang.doComplete(cssDocument, cssDocument.getGeneratedPosition(position), cssDocument.stylesheet);
        return vscode_languageserver_1.CompletionList.create([...(results ? results.items : []), ...emmetResults.items].map((completionItem) => documents_1.mapCompletionItemToOriginal(cssDocument, completionItem)), 
        // Emmet completions change on every keystroke, so they are never complete
        emmetResults.items.length > 0);
    }
    getDocumentColors(document) {
        if (!this.featureEnabled('documentColors')) {
            return [];
        }
        const cssDocument = this.getCSSDoc(document);
        if (isSASS(cssDocument)) {
            return [];
        }
        return service_1.getLanguageService(extractLanguage(cssDocument))
            .findDocumentColors(cssDocument, cssDocument.stylesheet)
            .map((colorInfo) => documents_1.mapColorInformationToOriginal(cssDocument, colorInfo));
    }
    getColorPresentations(document, range, color) {
        if (!this.featureEnabled('colorPresentations')) {
            return [];
        }
        const cssDocument = this.getCSSDoc(document);
        if ((!cssDocument.isInGenerated(range.start) && !cssDocument.isInGenerated(range.end)) ||
            isSASS(cssDocument)) {
            return [];
        }
        return service_1.getLanguageService(extractLanguage(cssDocument))
            .getColorPresentations(cssDocument, cssDocument.stylesheet, color, documents_1.mapRangeToGenerated(cssDocument, range))
            .map((colorPres) => documents_1.mapColorPresentationToOriginal(cssDocument, colorPres));
    }
    getDocumentSymbols(document) {
        if (!this.featureEnabled('documentColors')) {
            return [];
        }
        const cssDocument = this.getCSSDoc(document);
        if (isSASS(cssDocument)) {
            return [];
        }
        return service_1.getLanguageService(extractLanguage(cssDocument))
            .findDocumentSymbols(cssDocument, cssDocument.stylesheet)
            .map((symbol) => {
            if (!symbol.containerName) {
                return {
                    ...symbol,
                    // TODO: this could contain other things, e.g. style.myclass
                    containerName: 'style',
                };
            }
            return symbol;
        })
            .map((symbol) => documents_1.mapSymbolInformationToOriginal(cssDocument, symbol));
    }
    getCSSDoc(document) {
        let cssDoc = this.cssDocuments.get(document);
        if (!cssDoc || cssDoc.version < document.version) {
            cssDoc = new CSSDocument_1.CSSDocument(document);
            this.cssDocuments.set(document, cssDoc);
        }
        return cssDoc;
    }
    featureEnabled(feature) {
        return (this.configManager.enabled('css.enable') &&
            this.configManager.enabled(`css.${feature}.enable`));
    }
}
exports.CSSPlugin = CSSPlugin;
function shouldExcludeValidation(kind) {
    switch (kind) {
        case 'postcss':
        case 'text/postcss':
            return true;
        default:
            return false;
    }
}
function isSASS(document) {
    switch (extractLanguage(document)) {
        case 'sass':
        case 'text/sass':
            return true;
        default:
            return false;
    }
}
function extractLanguage(document) {
    const attrs = document.getAttributes();
    return attrs.lang || attrs.type;
}
//# sourceMappingURL=CSSPlugin.js.map