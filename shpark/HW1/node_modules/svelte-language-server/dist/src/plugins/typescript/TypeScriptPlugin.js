"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeScriptPlugin = void 0;
const typescript_1 = __importDefault(require("typescript"));
const vscode_languageserver_1 = require("vscode-languageserver");
const documents_1 = require("../../lib/documents");
const utils_1 = require("../../utils");
const CodeActionsProvider_1 = require("./features/CodeActionsProvider");
const CompletionProvider_1 = require("./features/CompletionProvider");
const DiagnosticsProvider_1 = require("./features/DiagnosticsProvider");
const UpdateImportsProvider_1 = require("./features/UpdateImportsProvider");
const LSAndTSDocResolver_1 = require("./LSAndTSDocResolver");
const utils_2 = require("./utils");
const RenameProvider_1 = require("./features/RenameProvider");
class TypeScriptPlugin {
    constructor(docManager, configManager, workspacePath) {
        this.configManager = configManager;
        this.lsAndTsDocResolver = new LSAndTSDocResolver_1.LSAndTSDocResolver(docManager, workspacePath);
        this.completionProvider = new CompletionProvider_1.CompletionsProviderImpl(this.lsAndTsDocResolver);
        this.codeActionsProvider = new CodeActionsProvider_1.CodeActionsProviderImpl(this.lsAndTsDocResolver);
        this.updateImportsProvider = new UpdateImportsProvider_1.UpdateImportsProviderImpl(this.lsAndTsDocResolver);
        this.diagnosticsProvider = new DiagnosticsProvider_1.DiagnosticsProviderImpl(this.lsAndTsDocResolver);
        this.renameProvider = new RenameProvider_1.RenameProviderImpl(this.lsAndTsDocResolver);
    }
    async getDiagnostics(document) {
        if (!this.featureEnabled('diagnostics')) {
            return [];
        }
        return this.diagnosticsProvider.getDiagnostics(document);
    }
    async doHover(document, position) {
        if (!this.featureEnabled('hover')) {
            return null;
        }
        const { lang, tsDoc } = this.getLSAndTSDoc(document);
        const fragment = await tsDoc.getFragment();
        const info = lang.getQuickInfoAtPosition(tsDoc.filePath, fragment.offsetAt(fragment.getGeneratedPosition(position)));
        if (!info) {
            return null;
        }
        const declaration = typescript_1.default.displayPartsToString(info.displayParts);
        const documentation = typeof info.documentation === 'string'
            ? info.documentation
            : typescript_1.default.displayPartsToString(info.documentation);
        // https://microsoft.github.io/language-server-protocol/specification#textDocument_hover
        const contents = ['```typescript', declaration, '```']
            .concat(documentation ? ['---', documentation] : [])
            .join('\n');
        return documents_1.mapHoverToParent(fragment, {
            range: utils_2.convertRange(fragment, info.textSpan),
            contents,
        });
    }
    async getDocumentSymbols(document) {
        if (!this.featureEnabled('documentSymbols')) {
            return [];
        }
        const { lang, tsDoc } = this.getLSAndTSDoc(document);
        const fragment = await tsDoc.getFragment();
        const navTree = lang.getNavigationTree(tsDoc.filePath);
        const symbols = [];
        collectSymbols(navTree, undefined, (symbol) => symbols.push(symbol));
        const topContainerName = symbols[0].name;
        return (symbols
            .slice(1)
            .map((symbol) => {
            if (symbol.containerName === topContainerName) {
                return { ...symbol, containerName: 'script' };
            }
            return symbol;
        })
            .map((symbol) => documents_1.mapSymbolInformationToOriginal(fragment, symbol))
            // Due to svelte2tsx, there will also be some symbols that are unmapped.
            // Filter those out to keep the lsp from throwing errors
            .filter((symbol) => symbol.location.range.start.line >= 0 &&
            symbol.location.range.end.line >= 0));
        function collectSymbols(tree, container, cb) {
            const start = tree.spans[0];
            const end = tree.spans[tree.spans.length - 1];
            if (start && end) {
                cb(vscode_languageserver_1.SymbolInformation.create(tree.text, utils_2.symbolKindFromString(tree.kind), vscode_languageserver_1.Range.create(fragment.positionAt(start.start), fragment.positionAt(end.start + end.length)), fragment.getURL(), container));
            }
            if (tree.childItems) {
                for (const child of tree.childItems) {
                    collectSymbols(child, tree.text, cb);
                }
            }
        }
    }
    async getCompletions(document, position, completionContext) {
        if (!this.featureEnabled('completions')) {
            return null;
        }
        return this.completionProvider.getCompletions(document, position, completionContext);
    }
    async resolveCompletion(document, completionItem) {
        return this.completionProvider.resolveCompletion(document, completionItem);
    }
    async getDefinitions(document, position) {
        if (!this.featureEnabled('definitions')) {
            return [];
        }
        const { lang, tsDoc } = this.getLSAndTSDoc(document);
        const fragment = await tsDoc.getFragment();
        const defs = lang.getDefinitionAndBoundSpan(tsDoc.filePath, fragment.offsetAt(fragment.getGeneratedPosition(position)));
        if (!defs || !defs.definitions) {
            return [];
        }
        const docs = new Map([[tsDoc.filePath, fragment]]);
        return await Promise.all(defs.definitions.map(async (def) => {
            let defDoc = docs.get(def.fileName);
            if (!defDoc) {
                defDoc = await this.getSnapshot(def.fileName).getFragment();
                docs.set(def.fileName, defDoc);
            }
            return vscode_languageserver_1.LocationLink.create(utils_1.pathToUrl(def.fileName), utils_2.convertToLocationRange(defDoc, def.textSpan), utils_2.convertToLocationRange(defDoc, def.textSpan), utils_2.convertToLocationRange(fragment, defs.textSpan));
        }));
    }
    async prepareRename(document, position) {
        if (!this.featureEnabled('rename')) {
            return null;
        }
        return this.renameProvider.prepareRename(document, position);
    }
    async rename(document, position, newName) {
        if (!this.featureEnabled('rename')) {
            return null;
        }
        return this.renameProvider.rename(document, position, newName);
    }
    async getCodeActions(document, range, context) {
        if (!this.featureEnabled('codeActions')) {
            return [];
        }
        return this.codeActionsProvider.getCodeActions(document, range, context);
    }
    async executeCommand(document, command, args) {
        if (!this.featureEnabled('codeActions')) {
            return null;
        }
        return this.codeActionsProvider.executeCommand(document, command, args);
    }
    async updateImports(fileRename) {
        if (!this.featureEnabled('rename')) {
            return null;
        }
        return this.updateImportsProvider.updateImports(fileRename);
    }
    onWatchFileChanges(fileName, changeType) {
        const scriptKind = utils_2.getScriptKindFromFileName(fileName);
        if (scriptKind === typescript_1.default.ScriptKind.Unknown) {
            // We don't deal with svelte files here
            return;
        }
        const snapshotManager = this.getSnapshotManager(fileName);
        if (changeType === vscode_languageserver_1.FileChangeType.Deleted) {
            snapshotManager.delete(fileName);
            return;
        }
        // Since the options parameter only applies to svelte snapshots, and this is not
        // a svelte file, we can just set it to false without having any effect.
        snapshotManager.updateByFileName(fileName, { strictMode: false });
    }
    getLSAndTSDoc(document) {
        return this.lsAndTsDocResolver.getLSAndTSDoc(document);
    }
    getSnapshot(filePath, document) {
        return this.lsAndTsDocResolver.getSnapshot(filePath, document);
    }
    /**
     *
     * @internal
     */
    getSnapshotManager(fileName) {
        return this.lsAndTsDocResolver.getSnapshotManager(fileName);
    }
    featureEnabled(feature) {
        return (this.configManager.enabled('typescript.enable') &&
            this.configManager.enabled(`typescript.${feature}.enable`));
    }
}
exports.TypeScriptPlugin = TypeScriptPlugin;
//# sourceMappingURL=TypeScriptPlugin.js.map