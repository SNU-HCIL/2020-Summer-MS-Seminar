import { Position, WorkspaceEdit, Range } from 'vscode-languageserver';
import { Document } from '../../../lib/documents';
import { RenameProvider } from '../../interfaces';
import { LSAndTSDocResolver } from '../LSAndTSDocResolver';
export declare class RenameProviderImpl implements RenameProvider {
    private readonly lsAndTsDocResolver;
    constructor(lsAndTsDocResolver: LSAndTSDocResolver);
    prepareRename(document: Document, position: Position): Promise<Range | null>;
    rename(document: Document, position: Position, newName: string): Promise<WorkspaceEdit | null>;
    private getRenameInfo;
    /**
     * If user renames prop of component A inside component A,
     * we need to handle the rename of the prop of A ourselves.
     * Reason: the rename will do {oldPropName: newPropName}, we have to handle
     * the conversion to {newPropName: newPropName} ourselves.
     */
    private getAdditionLocationsForRenameOfPropInsideComponentWithProp;
    /**
     * If user renames prop of component A inside component B,
     * we need to handle the rename of the prop of A ourselves.
     * Reason: the rename will rename the prop in the computed svelte2tsx code,
     * but not the `export let X` code in the original. This additional logic
     * is done in this method.
     */
    private getAdditionalLocationsForRenameOfPropInsideOtherComponent;
    private matchGeneratedExportLet;
    private findLocationWhichWantsToUpdatePropName;
    private isInSvelte2TsxPropLine;
    /**
     * The rename locations the ts language services hands back are relative to the
     * svelte2tsx generated code -> map it back to the original document positions.
     * Some of those positions could be unmapped (line=-1), these are handled elsewhere.
     */
    private mapRenameLocationsToParent;
    private mapRangeToOriginal;
    private getVariableAtPosition;
    private getLSAndTSDoc;
    private getSnapshot;
}
