"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLanguageService = exports.getService = exports.getLanguageServiceForDocument = exports.getLanguageServiceForPath = void 0;
const path_1 = require("path");
const typescript_1 = __importDefault(require("typescript"));
const logger_1 = require("../../logger");
const importPackage_1 = require("../../importPackage");
const DocumentSnapshot_1 = require("./DocumentSnapshot");
const module_loader_1 = require("./module-loader");
const SnapshotManager_1 = require("./SnapshotManager");
const utils_1 = require("./utils");
const services = new Map();
function getLanguageServiceForPath(path, workspacePath, createDocument) {
    return getService(path, workspacePath, createDocument).getService();
}
exports.getLanguageServiceForPath = getLanguageServiceForPath;
function getLanguageServiceForDocument(document, workspacePath, createDocument) {
    return getService(document.getFilePath() || '', workspacePath, createDocument).updateDocument(document);
}
exports.getLanguageServiceForDocument = getLanguageServiceForDocument;
function getService(path, workspacePath, createDocument) {
    const tsconfigPath = utils_1.findTsConfigPath(path, workspacePath);
    let service;
    if (services.has(tsconfigPath)) {
        service = services.get(tsconfigPath);
    }
    else {
        logger_1.Logger.log('Initialize new ts service at ', tsconfigPath);
        service = createLanguageService(tsconfigPath, createDocument);
        services.set(tsconfigPath, service);
    }
    return service;
}
exports.getService = getService;
function createLanguageService(tsconfigPath, createDocument) {
    const workspacePath = tsconfigPath ? path_1.dirname(tsconfigPath) : '';
    const { compilerOptions, files } = getCompilerOptionsAndProjectFiles();
    const snapshotManager = new SnapshotManager_1.SnapshotManager(files);
    const svelteModuleLoader = module_loader_1.createSvelteModuleLoader(getSnapshot, compilerOptions);
    const svelteTsPath = path_1.dirname(require.resolve('svelte2tsx'));
    const svelteTsxFiles = ['./svelte-shims.d.ts', './svelte-jsx.d.ts', './svelte-native-jsx.d.ts'].map((f) => typescript_1.default.sys.resolvePath(path_1.resolve(svelteTsPath, f)));
    const host = {
        getCompilationSettings: () => compilerOptions,
        getScriptFileNames: () => Array.from(new Set([
            ...snapshotManager.getProjectFileNames(),
            ...snapshotManager.getFileNames(),
            ...svelteTsxFiles,
        ])),
        getScriptVersion: (fileName) => getSnapshot(fileName).version.toString(),
        getScriptSnapshot: getSnapshot,
        getCurrentDirectory: () => workspacePath,
        getDefaultLibFileName: typescript_1.default.getDefaultLibFilePath,
        fileExists: svelteModuleLoader.fileExists,
        readFile: svelteModuleLoader.readFile,
        resolveModuleNames: svelteModuleLoader.resolveModuleNames,
        readDirectory: svelteModuleLoader.readDirectory,
        getDirectories: typescript_1.default.sys.getDirectories,
        // vscode's uri is all lowercase
        useCaseSensitiveFileNames: () => false,
        getScriptKind: (fileName) => getSnapshot(fileName).scriptKind,
    };
    let languageService = typescript_1.default.createLanguageService(host);
    return {
        tsconfigPath,
        compilerOptions,
        getService: () => languageService,
        updateDocument,
        deleteDocument,
        snapshotManager,
    };
    function deleteDocument(filePath) {
        svelteModuleLoader.deleteFromModuleCache(filePath);
        snapshotManager.delete(filePath);
    }
    function updateDocument(document) {
        const preSnapshot = snapshotManager.get(document.getFilePath());
        // Don't reinitialize document if no update needed.
        if ((preSnapshot === null || preSnapshot === void 0 ? void 0 : preSnapshot.version) === document.version) {
            return languageService;
        }
        const newSnapshot = DocumentSnapshot_1.DocumentSnapshot.fromDocument(document, {
            strictMode: !!compilerOptions.strict,
        });
        if (preSnapshot && preSnapshot.scriptKind !== newSnapshot.scriptKind) {
            // Restart language service as it doesn't handle script kind changes.
            languageService.dispose();
            languageService = typescript_1.default.createLanguageService(host);
        }
        snapshotManager.set(document.getFilePath(), newSnapshot);
        return languageService;
    }
    function getSnapshot(fileName) {
        fileName = utils_1.ensureRealSvelteFilePath(fileName);
        let doc = snapshotManager.get(fileName);
        if (doc) {
            return doc;
        }
        if (utils_1.isSvelteFilePath(fileName)) {
            const file = typescript_1.default.sys.readFile(fileName) || '';
            doc = DocumentSnapshot_1.DocumentSnapshot.fromDocument(createDocument(fileName, file), {
                strictMode: !!compilerOptions.strict,
            });
        }
        else {
            doc = DocumentSnapshot_1.DocumentSnapshot.fromFilePath(fileName, { strictMode: !!compilerOptions.strict });
        }
        snapshotManager.set(fileName, doc);
        return doc;
    }
    function getCompilerOptionsAndProjectFiles() {
        var _a, _b;
        const forcedCompilerOptions = {
            allowNonTsExtensions: true,
            target: typescript_1.default.ScriptTarget.Latest,
            module: typescript_1.default.ModuleKind.ESNext,
            moduleResolution: typescript_1.default.ModuleResolutionKind.NodeJs,
            allowJs: true,
            noEmit: true,
            declaration: false,
            skipLibCheck: true,
            // these are needed to handle the results of svelte2tsx preprocessing:
            jsx: typescript_1.default.JsxEmit.Preserve
        };
        // always let ts parse config to get default compilerOption
        let configJson = (tsconfigPath && typescript_1.default.readConfigFile(tsconfigPath, typescript_1.default.sys.readFile).config) ||
            getDefaultJsConfig();
        // Only default exclude when no extends for now
        if (!configJson.extends) {
            configJson = Object.assign({
                exclude: getDefaultExclude(),
            }, configJson);
        }
        const parsedConfig = typescript_1.default.parseJsonConfigFileContent(configJson, typescript_1.default.sys, workspacePath, forcedCompilerOptions, tsconfigPath, undefined, [{ extension: 'svelte', isMixedContent: false, scriptKind: typescript_1.default.ScriptKind.TSX }]);
        const files = parsedConfig.fileNames;
        const sveltePkgInfo = importPackage_1.getPackageInfo('svelte', workspacePath || process.cwd());
        const types = ((_b = (_a = parsedConfig.options) === null || _a === void 0 ? void 0 : _a.types) !== null && _b !== void 0 ? _b : []).concat(path_1.resolve(sveltePkgInfo.path, 'types', 'runtime'));
        const compilerOptions = {
            ...parsedConfig.options,
            types,
            ...forcedCompilerOptions,
        };
        // detect which JSX namespace to use (svelte | svelteNative) if not specified or not compatible
        if (!compilerOptions.jsxFactory || !compilerOptions.jsxFactory.startsWith("svelte")) {
            //default to regular svelte, this causes the usage of the "svelte.JSX" namespace
            compilerOptions.jsxFactory = "svelte.createElement";
            //override if we detect svelte-native
            if (workspacePath) {
                try {
                    const svelteNativePkgInfo = importPackage_1.getPackageInfo('svelte-native', workspacePath);
                    if (svelteNativePkgInfo.path) {
                        compilerOptions.jsxFactory = "svelteNative.createElement";
                    }
                }
                catch (e) {
                    //we stay regular svelte
                }
            }
        }
        return { compilerOptions, files };
    }
    /**
     * This should only be used when there's no jsconfig/tsconfig at all
     */
    function getDefaultJsConfig() {
        return {
            compilerOptions: {
                maxNodeModuleJsDepth: 2,
                allowSyntheticDefaultImports: true,
            },
            // Necessary to not flood the initial files
            // with potentially completely unrelated .ts/.js files:
            include: [],
        };
    }
    function getDefaultExclude() {
        return ['__sapper__', 'node_modules'];
    }
}
exports.createLanguageService = createLanguageService;
//# sourceMappingURL=service.js.map