"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTMLPlugin = void 0;
const vscode_emmet_helper_1 = require("vscode-emmet-helper");
const vscode_html_languageservice_1 = require("vscode-html-languageservice");
const vscode_languageserver_1 = require("vscode-languageserver");
const documents_1 = require("../../lib/documents");
const dataProvider_1 = require("./dataProvider");
class HTMLPlugin {
    constructor(docManager, configManager) {
        this.lang = vscode_html_languageservice_1.getLanguageService({ customDataProviders: [dataProvider_1.svelteHtmlDataProvider] });
        this.documents = new WeakMap();
        this.configManager = configManager;
        docManager.on('documentChange', (document) => {
            const html = this.lang.parseHTMLDocument(document);
            this.documents.set(document, html);
        });
    }
    doHover(document, position) {
        if (!this.featureEnabled('hover')) {
            return null;
        }
        const html = this.documents.get(document);
        if (!html) {
            return null;
        }
        return this.lang.doHover(document, position, html);
    }
    getCompletions(document, position) {
        if (!this.featureEnabled('completions')) {
            return null;
        }
        const html = this.documents.get(document);
        if (!html) {
            return null;
        }
        if (this.isInsideMoustacheTag(html, document, position) ||
            documents_1.isInTag(position, document.scriptInfo) ||
            documents_1.isInTag(position, document.moduleScriptInfo)) {
            return null;
        }
        const emmetResults = {
            isIncomplete: true,
            items: [],
        };
        this.lang.setCompletionParticipants([
            vscode_emmet_helper_1.getEmmetCompletionParticipants(document, position, 'html', {}, emmetResults),
        ]);
        const results = this.lang.doComplete(document, position, html);
        return vscode_languageserver_1.CompletionList.create([...results.items, ...emmetResults.items], 
        // Emmet completions change on every keystroke, so they are never complete
        emmetResults.items.length > 0);
    }
    doTagComplete(document, position) {
        if (!this.featureEnabled('tagComplete')) {
            return null;
        }
        const html = this.documents.get(document);
        if (!html) {
            return null;
        }
        if (this.isInsideMoustacheTag(html, document, position)) {
            return null;
        }
        return this.lang.doTagComplete(document, position, html);
    }
    isInsideMoustacheTag(html, document, position) {
        const offset = document.offsetAt(position);
        const node = html.findNodeAt(offset);
        const charactersInNode = document.getText().substring(node.start, offset);
        return charactersInNode.lastIndexOf('{') > charactersInNode.lastIndexOf('}');
    }
    getDocumentSymbols(document) {
        if (!this.featureEnabled('documentSymbols')) {
            return [];
        }
        const html = this.documents.get(document);
        if (!html) {
            return [];
        }
        return this.lang.findDocumentSymbols(document, html);
    }
    featureEnabled(feature) {
        return (this.configManager.enabled('html.enable') &&
            this.configManager.enabled(`html.${feature}.enable`));
    }
}
exports.HTMLPlugin = HTMLPlugin;
//# sourceMappingURL=HTMLPlugin.js.map