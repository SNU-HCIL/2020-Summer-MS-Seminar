"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SveltePlugin = void 0;
const cosmiconfig_1 = require("cosmiconfig");
const vscode_languageserver_1 = require("vscode-languageserver");
const importPackage_1 = require("../../importPackage");
const getCodeActions_1 = require("./features/getCodeActions");
const getCompletions_1 = require("./features/getCompletions");
const getDiagnostics_1 = require("./features/getDiagnostics");
const getHoverInfo_1 = require("./features/getHoverInfo");
const SvelteDocument_1 = require("./SvelteDocument");
class SveltePlugin {
    constructor(configManager, prettierConfig) {
        this.configManager = configManager;
        this.prettierConfig = prettierConfig;
        this.docManager = new Map();
        this.cosmiConfigExplorer = cosmiconfig_1.cosmiconfig('svelte', {
            packageProp: 'svelte-ls',
            cache: true,
        });
    }
    async getDiagnostics(document) {
        if (!this.featureEnabled('diagnostics')) {
            return [];
        }
        return getDiagnostics_1.getDiagnostics(document, await this.getSvelteDoc(document));
    }
    async getCompiledResult(document) {
        try {
            const svelteDoc = await this.getSvelteDoc(document);
            return svelteDoc.getCompiledWith({ generate: 'dom' });
        }
        catch (error) {
            return null;
        }
    }
    async formatDocument(document) {
        if (!this.featureEnabled('format')) {
            return [];
        }
        const filePath = document.getFilePath();
        const prettier = importPackage_1.importPrettier(filePath);
        // Try resolving the config through prettier and fall back to possible editor config
        const config = (await prettier.resolveConfig(filePath, { editorconfig: true })) || this.prettierConfig;
        const formattedCode = prettier.format(document.getText(), {
            ...config,
            plugins: [require.resolve('prettier-plugin-svelte')],
            parser: 'svelte',
        });
        return [
            vscode_languageserver_1.TextEdit.replace(vscode_languageserver_1.Range.create(document.positionAt(0), document.positionAt(document.getTextLength())), formattedCode),
        ];
    }
    async getCompletions(document, position) {
        if (!this.featureEnabled('completions')) {
            return null;
        }
        return getCompletions_1.getCompletions(await this.getSvelteDoc(document), position);
    }
    async doHover(document, position) {
        if (!this.featureEnabled('hover')) {
            return null;
        }
        return getHoverInfo_1.getHoverInfo(await this.getSvelteDoc(document), position);
    }
    async getCodeActions(document, range, context) {
        if (!this.featureEnabled('codeActions')) {
            return [];
        }
        const svelteDoc = await this.getSvelteDoc(document);
        try {
            return getCodeActions_1.getCodeActions(svelteDoc, range, context);
        }
        catch (error) {
            return [];
        }
    }
    async executeCommand(document, command, args) {
        if (!this.featureEnabled('codeActions')) {
            return null;
        }
        const svelteDoc = await this.getSvelteDoc(document);
        try {
            return getCodeActions_1.executeCommand(svelteDoc, command, args);
        }
        catch (error) {
            return null;
        }
    }
    featureEnabled(feature) {
        return (this.configManager.enabled('svelte.enable') &&
            this.configManager.enabled(`svelte.${feature}.enable`));
    }
    async getSvelteDoc(document) {
        let svelteDoc = this.docManager.get(document);
        if (!svelteDoc || svelteDoc.version !== document.version) {
            svelteDoc === null || svelteDoc === void 0 ? void 0 : svelteDoc.destroyTranspiled();
            svelteDoc = new SvelteDocument_1.SvelteDocument(document);
            this.docManager.set(document, svelteDoc);
        }
        return svelteDoc;
    }
}
exports.SveltePlugin = SveltePlugin;
//# sourceMappingURL=SveltePlugin.js.map