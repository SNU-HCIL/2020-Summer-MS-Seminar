"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SvelteFragmentMapper = exports.TranspiledSvelteDocument = exports.SvelteDocument = exports.TranspileErrorSource = void 0;
const source_map_1 = require("source-map");
const documents_1 = require("../../lib/documents");
const importPackage_1 = require("../../importPackage");
var TranspileErrorSource;
(function (TranspileErrorSource) {
    TranspileErrorSource["Script"] = "Script";
    TranspileErrorSource["Style"] = "Style";
})(TranspileErrorSource = exports.TranspileErrorSource || (exports.TranspileErrorSource = {}));
/**
 * Represents a text document that contains a svelte component.
 */
class SvelteDocument {
    constructor(parent) {
        this.parent = parent;
        this.languageId = 'svelte';
        this.version = 0;
        this.uri = this.parent.uri;
        this.config = this.parent.config;
        this.script = this.parent.scriptInfo;
        this.moduleScript = this.parent.moduleScriptInfo;
        this.style = this.parent.styleInfo;
        this.version = this.parent.version;
    }
    getText() {
        return this.parent.getText();
    }
    getFilePath() {
        return this.parent.getFilePath() || '';
    }
    offsetAt(position) {
        return this.parent.offsetAt(position);
    }
    async getTranspiled() {
        if (!this.transpiledDoc) {
            this.transpiledDoc = await TranspiledSvelteDocument.create(this.parent, this.parent.config.preprocess);
        }
        return this.transpiledDoc;
    }
    async getCompiled() {
        if (!this.compileResult) {
            this.compileResult = await this.getCompiledWith(this.parent.config.compilerOptions);
        }
        return this.compileResult;
    }
    async getCompiledWith(options = {}) {
        const svelte = importPackage_1.importSvelte(this.getFilePath());
        return svelte.compile((await this.getTranspiled()).getText(), options);
    }
    /**
     * Needs to be called before cleanup to prevent source map memory leaks.
     */
    destroyTranspiled() {
        if (this.transpiledDoc) {
            this.transpiledDoc.destroy();
            this.transpiledDoc = undefined;
        }
    }
}
exports.SvelteDocument = SvelteDocument;
class TranspiledSvelteDocument {
    constructor(parent, transpiled, scriptMapper, styleMapper) {
        this.parent = parent;
        this.transpiled = transpiled;
        this.scriptMapper = scriptMapper;
        this.styleMapper = styleMapper;
        this.fragmentInfos = [this.scriptMapper.fragmentInfo, this.styleMapper.fragmentInfo].sort((i1, i2) => i1.end - i2.end);
    }
    static async create(document, preprocessors = {}) {
        const { transpiled, processedScript, processedStyle } = await transpile(document, preprocessors);
        const scriptMapper = await SvelteFragmentMapper.createScript(document, transpiled, processedScript);
        const styleMapper = await SvelteFragmentMapper.createStyle(document, transpiled, processedStyle);
        return new TranspiledSvelteDocument(document, transpiled, scriptMapper, styleMapper);
    }
    getOriginalPosition(generatedPosition) {
        if (this.scriptMapper.isInTranspiledFragment(generatedPosition)) {
            return this.scriptMapper.getOriginalPosition(generatedPosition);
        }
        if (this.styleMapper.isInTranspiledFragment(generatedPosition)) {
            return this.styleMapper.getOriginalPosition(generatedPosition);
        }
        // Position is not in fragments, but we still need to account for
        // the length differences of the fragments before the position.
        let offset = documents_1.offsetAt(generatedPosition, this.transpiled);
        for (const fragmentInfo of this.fragmentInfos) {
            if (offset > fragmentInfo.end) {
                offset += fragmentInfo.diff;
            }
        }
        return this.parent.positionAt(offset);
    }
    getURL() {
        return this.parent.getURL();
    }
    getText() {
        return this.transpiled;
    }
    /**
     * Needs to be called before cleanup to prevent source map memory leaks.
     */
    destroy() {
        this.scriptMapper.destroy();
        this.styleMapper.destroy();
    }
}
exports.TranspiledSvelteDocument = TranspiledSvelteDocument;
class SvelteFragmentMapper {
    constructor(
    /**
     * End offset + length difference to original
     */
    fragmentInfo, 
    /**
     * Maps between full original source and fragment within that original.
     */
    originalFragmentMapper, 
    /**
     * Maps between full transpiled source and fragment within that transpiled.
     */
    transpiledFragmentMapper, 
    /**
     * Maps between original and transpiled, within fragment.
     */
    sourceMapper) {
        this.fragmentInfo = fragmentInfo;
        this.originalFragmentMapper = originalFragmentMapper;
        this.transpiledFragmentMapper = transpiledFragmentMapper;
        this.sourceMapper = sourceMapper;
    }
    static async createStyle(originalDoc, transpiled, processed) {
        return SvelteFragmentMapper.create(originalDoc, transpiled, originalDoc.styleInfo, documents_1.extractStyleTag(transpiled), processed);
    }
    static async createScript(originalDoc, transpiled, processed) {
        var _a;
        return SvelteFragmentMapper.create(originalDoc, transpiled, originalDoc.scriptInfo, ((_a = documents_1.extractScriptTags(transpiled)) === null || _a === void 0 ? void 0 : _a.script) || null, processed);
    }
    static async create(originalDoc, transpiled, originalTagInfo, transpiledTagInfo, processed) {
        const sourceMapper = (processed === null || processed === void 0 ? void 0 : processed.map) ? new documents_1.SourceMapDocumentMapper(await new source_map_1.SourceMapConsumer(processed.map.toString()), originalDoc.uri)
            : new documents_1.IdentityMapper(originalDoc.uri);
        if (originalTagInfo && transpiledTagInfo) {
            const sourceLength = originalTagInfo.container.end - originalTagInfo.container.start;
            const transpiledLength = transpiledTagInfo.container.end - transpiledTagInfo.container.start;
            const diff = sourceLength - transpiledLength;
            return new SvelteFragmentMapper({ end: transpiledTagInfo.container.end, diff }, new documents_1.FragmentMapper(originalDoc.getText(), originalTagInfo, originalDoc.uri), new documents_1.FragmentMapper(transpiled, transpiledTagInfo, originalDoc.uri), sourceMapper);
        }
        return new SvelteFragmentMapper({ end: -1, diff: 0 }, new documents_1.IdentityMapper(originalDoc.uri), new documents_1.IdentityMapper(originalDoc.uri), sourceMapper);
    }
    isInTranspiledFragment(generatedPosition) {
        return this.transpiledFragmentMapper.isInGenerated(generatedPosition);
    }
    getOriginalPosition(generatedPosition) {
        // Map the position to be relative to the transpiled fragment
        const positionInTranspiledFragment = this.transpiledFragmentMapper.getGeneratedPosition(generatedPosition);
        // Map the position, using the sourcemap, to the original position in the source fragment
        const positionInOriginalFragment = this.sourceMapper.getOriginalPosition(positionInTranspiledFragment);
        // Map the position to be in the original fragment's parent
        return this.originalFragmentMapper.getOriginalPosition(positionInOriginalFragment);
    }
    /**
     * Needs to be called before cleanup to prevent source map memory leaks.
     */
    destroy() {
        if (this.sourceMapper.destroy) {
            this.sourceMapper.destroy();
        }
    }
}
exports.SvelteFragmentMapper = SvelteFragmentMapper;
async function transpile(document, preprocessors = {}) {
    const preprocessor = {};
    let processedScript;
    let processedStyle;
    preprocessor.markup = preprocessors.markup;
    if (preprocessors.script) {
        preprocessor.script = async (args) => {
            try {
                const res = await preprocessors.script(args);
                if (res && res.map) {
                    processedScript = res;
                }
                return res;
            }
            catch (e) {
                e.__source = TranspileErrorSource.Script;
                throw e;
            }
        };
    }
    if (preprocessors.style) {
        preprocessor.style = async (args) => {
            try {
                const res = await preprocessors.style(args);
                if (res && res.map) {
                    processedStyle = res;
                }
                return res;
            }
            catch (e) {
                e.__source = TranspileErrorSource.Style;
                throw e;
            }
        };
    }
    const svelte = importPackage_1.importSvelte(document.getFilePath() || '');
    const transpiled = (await svelte.preprocess(document.getText(), preprocessor, {
        filename: document.getFilePath() || '',
    })).toString();
    return { transpiled, processedScript, processedStyle };
}
//# sourceMappingURL=SvelteDocument.js.map