"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginHost = void 0;
const lodash_1 = require("lodash");
const vscode_languageserver_1 = require("vscode-languageserver");
const logger_1 = require("../logger");
const utils_1 = require("../utils");
var ExecuteMode;
(function (ExecuteMode) {
    ExecuteMode[ExecuteMode["None"] = 0] = "None";
    ExecuteMode[ExecuteMode["FirstNonNull"] = 1] = "FirstNonNull";
    ExecuteMode[ExecuteMode["Collect"] = 2] = "Collect";
})(ExecuteMode || (ExecuteMode = {}));
class PluginHost {
    constructor(documentsManager, config) {
        this.documentsManager = documentsManager;
        this.config = config;
        this.filterIncompleteCompletions = false;
        this.plugins = [];
    }
    initialize(dontFilterIncompleteCompletions) {
        this.filterIncompleteCompletions = !dontFilterIncompleteCompletions;
    }
    register(plugin) {
        this.plugins.push(plugin);
    }
    updateConfig(config) {
        this.config.update(config);
    }
    async getDiagnostics(textDocument) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return lodash_1.flatten(await this.execute('getDiagnostics', [document], ExecuteMode.Collect));
    }
    async doHover(textDocument, position) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return this.execute('doHover', [document, position], ExecuteMode.FirstNonNull);
    }
    async getCompletions(textDocument, position, completionContext) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        const completions = (await this.execute('getCompletions', [document, position, completionContext], ExecuteMode.Collect)).filter((completion) => completion != null);
        let flattenedCompletions = lodash_1.flatten(completions.map((completion) => completion.items));
        const isIncomplete = completions.reduce((incomplete, completion) => incomplete || completion.isIncomplete, false);
        // If the result is incomplete, we need to filter the results ourselves
        // to throw out non-matching results. VSCode does filter client-side,
        // but other IDEs might not.
        if (isIncomplete && this.filterIncompleteCompletions) {
            const offset = document.offsetAt(position);
            // Assumption for performance reasons:
            // Noone types import names longer than 20 characters and still expects perfect autocompletion.
            const text = document.getText().substring(Math.max(0, offset - 20), offset);
            const start = utils_1.regexLastIndexOf(text, /[\W\s]/g) + 1;
            const filterValue = text.substring(start).toLowerCase();
            flattenedCompletions = flattenedCompletions.filter((comp) => comp.label.toLowerCase().includes(filterValue));
        }
        return vscode_languageserver_1.CompletionList.create(flattenedCompletions, isIncomplete);
    }
    async resolveCompletion(textDocument, completionItem) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        const result = await this.execute('resolveCompletion', [document, completionItem], ExecuteMode.FirstNonNull);
        return result !== null && result !== void 0 ? result : completionItem;
    }
    async formatDocument(textDocument) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return lodash_1.flatten(await this.execute('formatDocument', [document], ExecuteMode.Collect));
    }
    async doTagComplete(textDocument, position) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return this.execute('doTagComplete', [document, position], ExecuteMode.FirstNonNull);
    }
    async getDocumentColors(textDocument) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return lodash_1.flatten(await this.execute('getDocumentColors', [document], ExecuteMode.Collect));
    }
    async getColorPresentations(textDocument, range, color) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return lodash_1.flatten(await this.execute('getColorPresentations', [document, range, color], ExecuteMode.Collect));
    }
    async getDocumentSymbols(textDocument) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return lodash_1.flatten(await this.execute('getDocumentSymbols', [document], ExecuteMode.Collect));
    }
    async getDefinitions(textDocument, position) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return lodash_1.flatten(await this.execute('getDefinitions', [document, position], ExecuteMode.Collect));
    }
    async getCodeActions(textDocument, range, context) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return lodash_1.flatten(await this.execute('getCodeActions', [document, range, context], ExecuteMode.Collect));
    }
    async executeCommand(textDocument, command, args) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return await this.execute('executeCommand', [document, command, args], ExecuteMode.FirstNonNull);
    }
    async updateImports(fileRename) {
        return await this.execute('updateImports', [fileRename], ExecuteMode.FirstNonNull);
    }
    async prepareRename(textDocument, position) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return await this.execute('prepareRename', [document, position], ExecuteMode.FirstNonNull);
    }
    async rename(textDocument, position, newName) {
        const document = this.getDocument(textDocument.uri);
        if (!document) {
            throw new Error('Cannot call methods on an unopened document');
        }
        return await this.execute('rename', [document, position, newName], ExecuteMode.FirstNonNull);
    }
    onWatchFileChanges(fileName, changeType) {
        var _a;
        for (const support of this.plugins) {
            (_a = support.onWatchFileChanges) === null || _a === void 0 ? void 0 : _a.call(support, fileName, changeType);
        }
    }
    getDocument(uri) {
        return this.documentsManager.documents.get(uri);
    }
    async execute(name, args, mode) {
        const plugins = this.plugins.filter((plugin) => typeof plugin[name] === 'function');
        switch (mode) {
            case ExecuteMode.FirstNonNull:
                for (const plugin of plugins) {
                    const res = await this.tryExecutePlugin(plugin, name, args, null);
                    if (res != null) {
                        return res;
                    }
                }
                return null;
            case ExecuteMode.Collect:
                return Promise.all(plugins.map((plugin) => this.tryExecutePlugin(plugin, name, args, [])));
            case ExecuteMode.None:
                await Promise.all(plugins.map((plugin) => this.tryExecutePlugin(plugin, name, args, null)));
                return;
        }
    }
    async tryExecutePlugin(plugin, fnName, args, failValue) {
        try {
            return await plugin[fnName](...args);
        }
        catch (e) {
            logger_1.Logger.error(e);
            return failValue;
        }
    }
}
exports.PluginHost = PluginHost;
//# sourceMappingURL=PluginHost.js.map