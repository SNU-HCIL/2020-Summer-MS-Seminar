"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateRelativeImport = exports.getLineAtPosition = exports.getTextInRange = exports.isRangeInTag = exports.isInTag = exports.offsetAt = exports.positionAt = exports.extractStyleTag = exports.extractScriptTags = void 0;
const utils_1 = require("../../utils");
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_html_languageservice_1 = require("vscode-html-languageservice");
const path = __importStar(require("path"));
function parseAttributes(rawAttrs) {
    const attrs = {};
    if (!rawAttrs) {
        return attrs;
    }
    Object.keys(rawAttrs).forEach((attrName) => {
        const attrValue = rawAttrs[attrName];
        attrs[attrName] = attrValue === null ? attrName : removeOuterQuotes(attrValue);
    });
    return attrs;
    function removeOuterQuotes(attrValue) {
        if ((attrValue.startsWith('"') && attrValue.endsWith('"')) ||
            (attrValue.startsWith("'") && attrValue.endsWith("'"))) {
            return attrValue.slice(1, attrValue.length - 1);
        }
        return attrValue;
    }
}
const parser = vscode_html_languageservice_1.getLanguageService();
function parseHtml(text) {
    // We can safely only set getText because only this is used for parsing
    return parser.parseHTMLDocument({ getText: () => text });
}
const regexIf = new RegExp('{#if\\s.*?}', 'igms');
const regexIfEnd = new RegExp('{/if}', 'igms');
const regexEach = new RegExp('{#each\\s.*?}', 'igms');
const regexEachEnd = new RegExp('{/each}', 'igms');
const regexAwait = new RegExp('{#await\\s.*?}', 'igms');
const regexAwaitEnd = new RegExp('{/await}', 'igms');
const regexHtml = new RegExp('{@html\\s.*?', 'igms');
/**
 * Extracts a tag (style or script) from the given text
 * and returns its start, end and the attributes on that tag.
 *
 * @param source text content to extract tag from
 * @param tag the tag to extract
 */
function extractTags(text, tag) {
    const rootNodes = parseHtml(text).roots;
    const matchedNodes = rootNodes
        .filter((node) => node.tag === tag)
        .filter((tag) => {
        return isNotInsideControlFlowTag(tag) && isNotInsideHtmlTag(tag);
    });
    return matchedNodes.map(transformToTagInfo);
    /**
     * For every match AFTER the tag do a search for `{/X`.
     * If that is BEFORE `{#X`, we are inside a moustache tag.
     */
    function isNotInsideControlFlowTag(tag) {
        const nodes = rootNodes.slice(rootNodes.indexOf(tag));
        const rootContentAfterTag = nodes
            .map((node, idx) => {
            var _a;
            return text.substring(node.end, (_a = nodes[idx + 1]) === null || _a === void 0 ? void 0 : _a.start);
        })
            .join('');
        return ![
            [regexIf, regexIfEnd],
            [regexEach, regexEachEnd],
            [regexAwait, regexAwaitEnd],
        ].some((pair) => {
            var _a, _b;
            pair[0].lastIndex = 0;
            pair[1].lastIndex = 0;
            const start = pair[0].exec(rootContentAfterTag);
            const end = pair[1].exec(rootContentAfterTag);
            return ((_a = end === null || end === void 0 ? void 0 : end.index) !== null && _a !== void 0 ? _a : text.length) < ((_b = start === null || start === void 0 ? void 0 : start.index) !== null && _b !== void 0 ? _b : text.length);
        });
    }
    /**
     * For every match BEFORE the tag do a search for `{@html`.
     * If that is BEFORE `}`, we are inside a moustache tag.
     */
    function isNotInsideHtmlTag(tag) {
        const nodes = rootNodes.slice(0, rootNodes.indexOf(tag));
        const rootContentBeforeTag = [{ start: 0, end: 0 }, ...nodes]
            .map((node, idx) => {
            var _a;
            return text.substring(node.end, (_a = nodes[idx]) === null || _a === void 0 ? void 0 : _a.start);
        })
            .join('');
        return !(utils_1.regexLastIndexOf(rootContentBeforeTag, regexHtml) >
            rootContentBeforeTag.lastIndexOf('}'));
    }
    function transformToTagInfo(matchedNode) {
        var _a, _b;
        const start = (_a = matchedNode.startTagEnd) !== null && _a !== void 0 ? _a : matchedNode.start;
        const end = (_b = matchedNode.endTagStart) !== null && _b !== void 0 ? _b : matchedNode.end;
        const startPos = positionAt(start, text);
        const endPos = positionAt(end, text);
        const container = {
            start: matchedNode.start,
            end: matchedNode.end,
        };
        const content = text.substring(start, end);
        return {
            content,
            attributes: parseAttributes(matchedNode.attributes),
            start,
            end,
            startPos,
            endPos,
            container,
        };
    }
}
function extractScriptTags(source) {
    const scripts = extractTags(source, 'script');
    if (!scripts.length) {
        return null;
    }
    const script = scripts.find((s) => s.attributes['context'] !== 'module');
    const moduleScript = scripts.find((s) => s.attributes['context'] === 'module');
    return { script, moduleScript };
}
exports.extractScriptTags = extractScriptTags;
function extractStyleTag(source) {
    const styles = extractTags(source, 'style');
    if (!styles.length) {
        return null;
    }
    // There can only be one style tag
    return styles[0];
}
exports.extractStyleTag = extractStyleTag;
/**
 * Get the line and character based on the offset
 * @param offset The index of the position
 * @param text The text for which the position should be retrived
 */
function positionAt(offset, text) {
    offset = utils_1.clamp(offset, 0, text.length);
    const lineOffsets = getLineOffsets(text);
    let low = 0;
    let high = lineOffsets.length;
    if (high === 0) {
        return vscode_languageserver_1.Position.create(0, offset);
    }
    while (low < high) {
        const mid = Math.floor((low + high) / 2);
        if (lineOffsets[mid] > offset) {
            high = mid;
        }
        else {
            low = mid + 1;
        }
    }
    // low is the least x for which the line offset is larger than the current offset
    // or array.length if no line offset is larger than the current offset
    const line = low - 1;
    return vscode_languageserver_1.Position.create(line, offset - lineOffsets[line]);
}
exports.positionAt = positionAt;
/**
 * Get the offset of the line and character position
 * @param position Line and character position
 * @param text The text for which the offset should be retrived
 */
function offsetAt(position, text) {
    const lineOffsets = getLineOffsets(text);
    if (position.line >= lineOffsets.length) {
        return text.length;
    }
    else if (position.line < 0) {
        return 0;
    }
    const lineOffset = lineOffsets[position.line];
    const nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : text.length;
    return utils_1.clamp(nextLineOffset, lineOffset, lineOffset + position.character);
}
exports.offsetAt = offsetAt;
function getLineOffsets(text) {
    const lineOffsets = [];
    let isLineStart = true;
    for (let i = 0; i < text.length; i++) {
        if (isLineStart) {
            lineOffsets.push(i);
            isLineStart = false;
        }
        const ch = text.charAt(i);
        isLineStart = ch === '\r' || ch === '\n';
        if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
            i++;
        }
    }
    if (isLineStart && text.length > 0) {
        lineOffsets.push(text.length);
    }
    return lineOffsets;
}
function isInTag(position, tagInfo) {
    return !!tagInfo && utils_1.isInRange(vscode_languageserver_1.Range.create(tagInfo.startPos, tagInfo.endPos), position);
}
exports.isInTag = isInTag;
function isRangeInTag(range, tagInfo) {
    return isInTag(range.start, tagInfo) && isInTag(range.end, tagInfo);
}
exports.isRangeInTag = isRangeInTag;
function getTextInRange(range, text) {
    return text.substring(offsetAt(range.start, text), offsetAt(range.end, text));
}
exports.getTextInRange = getTextInRange;
function getLineAtPosition(position, text) {
    return text.substring(offsetAt({ line: position.line, character: 0 }, text), offsetAt({ line: position.line, character: Number.MAX_VALUE }, text));
}
exports.getLineAtPosition = getLineAtPosition;
/**
 * Updates a relative import
 *
 * @param oldPath Old absolute path
 * @param newPath New absolute path
 * @param relativeImportPath Import relative to the old path
 */
function updateRelativeImport(oldPath, newPath, relativeImportPath) {
    let newImportPath = path
        .join(path.relative(newPath, oldPath), relativeImportPath)
        .replace(/\\/g, '/');
    if (!newImportPath.startsWith('.')) {
        newImportPath = './' + newImportPath;
    }
    return newImportPath;
}
exports.updateRelativeImport = updateRelativeImport;
//# sourceMappingURL=utils.js.map