"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapCodeActionToOriginal = exports.mapTextDocumentEditToOriginal = exports.mapLocationLinkToOriginal = exports.mapSymbolInformationToOriginal = exports.mapColorPresentationToOriginal = exports.mapColorInformationToOriginal = exports.mapDiagnosticToGenerated = exports.mapDiagnosticToOriginal = exports.mapHoverToParent = exports.mapCompletionItemToOriginal = exports.mapLocationToOriginal = exports.mapTextEditToOriginal = exports.mapRangeToGenerated = exports.mapRangeToOriginal = exports.SourceMapDocumentMapper = exports.FragmentMapper = exports.IdentityMapper = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const utils_1 = require("./utils");
const logger_1 = require("../../logger");
/**
 * Does not map, returns positions as is.
 */
class IdentityMapper {
    constructor(url) {
        this.url = url;
    }
    getOriginalPosition(generatedPosition) {
        return generatedPosition;
    }
    getGeneratedPosition(originalPosition) {
        return originalPosition;
    }
    isInGenerated() {
        return true;
    }
    getURL() {
        return this.url;
    }
}
exports.IdentityMapper = IdentityMapper;
/**
 * Maps positions in a fragment relative to a parent.
 */
class FragmentMapper {
    constructor(originalText, tagInfo, url) {
        this.originalText = originalText;
        this.tagInfo = tagInfo;
        this.url = url;
    }
    getOriginalPosition(generatedPosition) {
        const parentOffset = this.offsetInParent(utils_1.offsetAt(generatedPosition, this.tagInfo.content));
        return utils_1.positionAt(parentOffset, this.originalText);
    }
    offsetInParent(offset) {
        return this.tagInfo.start + offset;
    }
    getGeneratedPosition(originalPosition) {
        const fragmentOffset = utils_1.offsetAt(originalPosition, this.originalText) - this.tagInfo.start;
        return utils_1.positionAt(fragmentOffset, this.tagInfo.content);
    }
    isInGenerated(pos) {
        const offset = utils_1.offsetAt(pos, this.originalText);
        return offset >= this.tagInfo.start && offset <= this.tagInfo.end;
    }
    getURL() {
        return this.url;
    }
}
exports.FragmentMapper = FragmentMapper;
class SourceMapDocumentMapper {
    constructor(consumer, sourceUri) {
        this.consumer = consumer;
        this.sourceUri = sourceUri;
    }
    getOriginalPosition(generatedPosition) {
        const mapped = this.consumer.originalPositionFor({
            line: generatedPosition.line + 1,
            column: generatedPosition.character,
        });
        if (!mapped) {
            return { line: -1, character: -1 };
        }
        if (mapped.line === 0) {
            logger_1.Logger.log('Got 0 mapped line from', generatedPosition, 'col was', mapped.column);
        }
        return {
            line: (mapped.line || 0) - 1,
            character: mapped.column || 0,
        };
    }
    getGeneratedPosition(originalPosition) {
        const mapped = this.consumer.generatedPositionFor({
            line: originalPosition.line + 1,
            column: originalPosition.character,
            source: this.sourceUri,
        });
        if (!mapped) {
            return { line: -1, character: -1 };
        }
        const result = {
            line: (mapped.line || 0) - 1,
            character: mapped.column || 0,
        };
        if (result.line < 0) {
            return result;
        }
        return result;
    }
    isInGenerated(position) {
        const generated = this.getGeneratedPosition(position);
        return generated.line >= 0;
    }
    getURL() {
        return this.sourceUri;
    }
    /**
     * Needs to be called when source mapper is no longer needed in order to prevent memory leaks.
     */
    destroy() {
        this.consumer.destroy();
    }
}
exports.SourceMapDocumentMapper = SourceMapDocumentMapper;
function mapRangeToOriginal(fragment, range) {
    return vscode_languageserver_1.Range.create(fragment.getOriginalPosition(range.start), fragment.getOriginalPosition(range.end));
}
exports.mapRangeToOriginal = mapRangeToOriginal;
function mapRangeToGenerated(fragment, range) {
    return vscode_languageserver_1.Range.create(fragment.getGeneratedPosition(range.start), fragment.getGeneratedPosition(range.end));
}
exports.mapRangeToGenerated = mapRangeToGenerated;
function mapTextEditToOriginal(fragment, edit) {
    return { ...edit, range: mapRangeToOriginal(fragment, edit.range) };
}
exports.mapTextEditToOriginal = mapTextEditToOriginal;
function mapLocationToOriginal(fragment, loc) {
    return { ...loc, range: mapRangeToOriginal(fragment, loc.range) };
}
exports.mapLocationToOriginal = mapLocationToOriginal;
function mapCompletionItemToOriginal(fragment, item) {
    if (!item.textEdit) {
        return item;
    }
    return { ...item, textEdit: mapTextEditToOriginal(fragment, item.textEdit) };
}
exports.mapCompletionItemToOriginal = mapCompletionItemToOriginal;
function mapHoverToParent(fragment, hover) {
    if (!hover.range) {
        return hover;
    }
    return { ...hover, range: mapRangeToOriginal(fragment, hover.range) };
}
exports.mapHoverToParent = mapHoverToParent;
function mapDiagnosticToOriginal(fragment, diagnostic) {
    return { ...diagnostic, range: mapRangeToOriginal(fragment, diagnostic.range) };
}
exports.mapDiagnosticToOriginal = mapDiagnosticToOriginal;
function mapDiagnosticToGenerated(fragment, diagnostic) {
    return { ...diagnostic, range: mapRangeToGenerated(fragment, diagnostic.range) };
}
exports.mapDiagnosticToGenerated = mapDiagnosticToGenerated;
function mapColorInformationToOriginal(fragment, info) {
    return { ...info, range: mapRangeToOriginal(fragment, info.range) };
}
exports.mapColorInformationToOriginal = mapColorInformationToOriginal;
function mapColorPresentationToOriginal(fragment, presentation) {
    const item = {
        ...presentation,
    };
    if (item.textEdit) {
        item.textEdit = mapTextEditToOriginal(fragment, item.textEdit);
    }
    if (item.additionalTextEdits) {
        item.additionalTextEdits = item.additionalTextEdits.map((edit) => mapTextEditToOriginal(fragment, edit));
    }
    return item;
}
exports.mapColorPresentationToOriginal = mapColorPresentationToOriginal;
function mapSymbolInformationToOriginal(fragment, info) {
    return { ...info, location: mapLocationToOriginal(fragment, info.location) };
}
exports.mapSymbolInformationToOriginal = mapSymbolInformationToOriginal;
function mapLocationLinkToOriginal(fragment, def) {
    return vscode_languageserver_1.LocationLink.create(def.targetUri, fragment.getURL() === def.targetUri
        ? mapRangeToOriginal(fragment, def.targetRange)
        : def.targetRange, fragment.getURL() === def.targetUri
        ? mapRangeToOriginal(fragment, def.targetSelectionRange)
        : def.targetSelectionRange, def.originSelectionRange
        ? mapRangeToOriginal(fragment, def.originSelectionRange)
        : undefined);
}
exports.mapLocationLinkToOriginal = mapLocationLinkToOriginal;
function mapTextDocumentEditToOriginal(fragment, edit) {
    if (edit.textDocument.uri !== fragment.getURL()) {
        return edit;
    }
    return vscode_languageserver_1.TextDocumentEdit.create(edit.textDocument, edit.edits.map((textEdit) => mapTextEditToOriginal(fragment, textEdit)));
}
exports.mapTextDocumentEditToOriginal = mapTextDocumentEditToOriginal;
function mapCodeActionToOriginal(fragment, codeAction) {
    return vscode_languageserver_1.CodeAction.create(codeAction.title, {
        documentChanges: codeAction.edit.documentChanges.map((edit) => mapTextDocumentEditToOriginal(fragment, edit)),
    }, codeAction.kind);
}
exports.mapCodeActionToOriginal = mapCodeActionToOriginal;
//# sourceMappingURL=DocumentMapper.js.map