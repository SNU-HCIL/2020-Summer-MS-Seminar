"use strict";
/**
 * This code's groundwork is taken from https://github.com/vuejs/vetur/tree/master/vti
 */
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const glob = require("glob");
const argv = require("minimist");
const path = require("path");
const svelte_language_server_1 = require("svelte-language-server");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = require("vscode-uri");
const writers_1 = require("./writers");
const outputFormats = ['human', 'human-verbose', 'machine'];
async function getDiagnostics(workspaceUri, writer) {
    writer.start(workspaceUri.fsPath);
    const svelteCheck = new svelte_language_server_1.SvelteCheck(workspaceUri.fsPath);
    const files = glob.sync('**/*.svelte', {
        cwd: workspaceUri.fsPath,
        ignore: ['node_modules/**'],
    });
    const absFilePaths = files.map((f) => path.resolve(workspaceUri.fsPath, f));
    const result = {
        fileCount: absFilePaths.length,
        errorCount: 0,
        warningCount: 0,
    };
    for (const absFilePath of absFilePaths) {
        const text = fs.readFileSync(absFilePath, 'utf-8');
        let res = [];
        try {
            res = await svelteCheck.getDiagnostics({
                uri: vscode_uri_1.URI.file(absFilePath).toString(),
                text,
            });
        }
        catch (err) {
            writer.failure(err);
            return null;
        }
        writer.file(res, workspaceUri.fsPath, path.relative(workspaceUri.fsPath, absFilePath), text);
        res.forEach((d) => {
            if (d.severity === vscode_languageserver_protocol_1.DiagnosticSeverity.Error) {
                result.errorCount += 1;
            }
            else if (d.severity === vscode_languageserver_protocol_1.DiagnosticSeverity.Warning) {
                result.warningCount += 1;
            }
        });
    }
    writer.completion(result.fileCount, result.errorCount, result.warningCount);
    return result;
}
(async () => {
    const myArgs = argv(process.argv.slice(1));
    let workspaceUri;
    let workspacePath = myArgs['workspace'];
    if (workspacePath) {
        if (!path.isAbsolute(workspacePath)) {
            workspacePath = path.resolve(process.cwd(), workspacePath);
        }
        workspaceUri = vscode_uri_1.URI.file(workspacePath);
    }
    else {
        workspaceUri = vscode_uri_1.URI.file(process.cwd());
    }
    const outputFormat = outputFormats.includes(myArgs['output'])
        ? myArgs['output']
        : 'human-verbose';
    let writer;
    if (outputFormat === 'human-verbose' || outputFormat === 'human') {
        writer = new writers_1.HumanFriendlyWriter(process.stdout, outputFormat === 'human-verbose');
    }
    else {
        writer = new writers_1.MachineFriendlyWriter(process.stdout);
    }
    const result = await getDiagnostics(workspaceUri, writer);
    if (result && result.errorCount === 0) {
        process.exit(0);
    }
    else {
        process.exit(1);
    }
})().catch((_err) => {
    console.error(_err);
    console.error('svelte-check failed');
});
